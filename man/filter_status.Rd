% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_status.R
\name{filter_status}
\alias{filter_status}
\alias{drop_dead_stem}
\alias{drop_dead_tree}
\title{Filter a (fgeo) dataframe by the status of each stem or tree.}
\usage{
filter_status(x, wood, .status, exclude = FALSE)

drop_dead_stem(x, .status = "D")

drop_dead_tree(x, .status = "D")
}
\arguments{
\item{x}{A ForestGEO table, either a ViewFullTable or a census table.}

\item{wood}{Either "stem" or "tree", to indicate if the data should be
filtered based on the status of each individual stem or tree (notice that
one tree is dead only when not some but all its stems are dead).}

\item{.status}{Character vector; Must be one of possible values of the
variable giving the status of the dataframe \code{x}.}

\item{exclude}{Logical; \code{TRUE} filters the data to exclude the values passed
to \code{.status}.}
}
\value{
A filtered version of the dataframe \code{x}.
}
\description{
In stem- and ViewFull-tables \code{status} and \code{Status} refer to each stem. In
tree-tables \code{status} refers to tree. To get the status of each tree based
on the status of its stems see \code{\link[=add_status_tree]{add_status_tree()}}.
}
\examples{
library(dplyr)
library(fgeo.tool)

#' # Filter by the status of each stem (wood = "stem") -----------------------

# CENSUS TABLE: STEM TABLE

x <- fgeo.data::luquillo_stem_random_tiny
table(x$status)

result <- filter_status(x, wood = "stem", .status = "D")
table(result$status)

result <- filter_status(x, wood = "stem", .status = "D", exclude = TRUE)
table(result$status)
# Shortcut
result <- drop_dead_stem(x)
table(result$status)

# Warns
result <- filter_status(x, wood = "stem", .status = c("A", "wrong-status"))
table(result$status)

# CENSUS TABLE: TREE TABLE

# Works exactly in the same way
x <- fgeo.data::luquillo_tree6_random
table(x$status)

result <- filter_status(x, wood = "stem", .status = "D")
table(result$status)

# Shortcut
result <- drop_dead_stem(x)
table(result$status)

# VIEWFULL TABLE

# Works exactly in the same way, but notice the following:
# * The variable Status starts with capital S;
# * The values of Status are not, say "A" or "D", but "alive" or "dead".
x <- fgeo.data::luquillo_vft_4quad
table(x$Status)

result <- filter_status(x, wood = "stem", .status = "alive")
table(result$Status)

# Warns because `.status` defaults to "D" -- not to "dead".
result <- drop_dead_stem(x)
# Fix and repeat
result <- drop_dead_stem(x, .status = "dead")
table(result$Status)



# Filter by the status of each tree (wood = "tree") -----------------------

# CENSUS TABLE: STEM TABLE

x <- fgeo.data::luquillo_stem_random_tiny

# Add the variable status_tree, which gives the status of each tree, not stem
unique(x$status)
x <- add_status_tree(x, status_d = "D", status_a = "A")
table(x$status_tree)

result <- filter_status(x, wood = "tree", .status = "A")
table(result$status_tree)

result <- filter_status(x, wood = "tree", .status = "D", exclude = TRUE)
table(result$status_tree)

# Shortcut
result <- drop_dead_tree(x)
result \%>\%
  dplyr::arrange(treeID, stemID, status) \%>\%
  dplyr::select(treeID, stemID, status, status_tree)
table(result$status_tree)



# CENSUS TABLE: TREE TABLE
x <- fgeo.data::luquillo_tree6_random
# For a tree census-table, each stem maps to a tree, so the value of the
# variable `status` gives, at the same time, the status of the stem and tree.
x <- add_status_tree(x, "D", "A")
identical(x$status, x$status_tree)
# So the result will be the same if we use `wood = tree` or `wood = stem`.
result1 <- filter_status(x, wood = "tree", .status = "A")
result2 <- filter_status(x, wood = "stem", .status = "A")
identical(result1, result2)
# Shortcut
result <- drop_dead_tree(x, .status = "D")
identical(result, result1)



# VIEWFULL TABLE

x <- fgeo.data::luquillo_vft_4quad

# Add the variable status_tree, which gives the status of each tree, not stem
unique(x$Status)
x <- add_status_tree(x, status_d = "dead", status_a = "alive")
table(x$status_tree)

result <- filter_status(x, wood = "tree", .status = "alive")
table(result$status_tree)

# Shortcut
unique(x$Status)
result <- drop_dead_tree(x, "dead")
result \%>\%
  dplyr::arrange(TreeID, StemID, Status) \%>\%
  dplyr::select(TreeID, StemID, Status, status_tree)
table(result$status_tree)
}
\seealso{
\code{\link[=add_status_tree]{add_status_tree()}}, \code{\link[fgeo.base:drop_status]{fgeo.base::drop_status()}}.

Other functions to pick or drop rows of a dataframe.: \code{\link{drop_twice_dead}},
  \code{\link{pick_dbh_largest}},
  \code{\link{pick_recensus}}, \code{\link{pick_top}}
}
\concept{functions to pick or drop rows of a dataframe.}
