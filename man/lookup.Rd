% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lookup.R
\name{lookup}
\alias{lookup}
\title{Modify a vector to replace old with new values from a lookup table.}
\usage{
lookup(old, new)
}
\arguments{
\item{old, new}{Vectors of equal length giving old and new codes.}
}
\value{
A "spliced" list with names from \code{old} and values from \code{new}. The
kind of data structure that you can feed to \code{...} in dplyr::recode()`.
}
\description{
Use this function inside \code{dplyr::recode()} to recode a vector based on values
from two other vectors, where \code{old} and \code{new} codes are looked up. These
lookup vectors are commonly stored in a dataframe and come from a .csv or
spreadsheet file.
}
\section{Acknowledgment}{

Thanks to David Kenfack for inspiring this function.
}

\examples{
library(dplyr, warn.conflicts = FALSE)

look <- tibble(
  old = c("spp1", "unknown"),
  new = c("spp3", "spp4")
)

sp <- c("spp1", "spp2", "spp3", "unknown", "spp3", "unknown", "spp1", "spp1")
recode(sp, lookup(look$old, look$new))

census <- tibble(sp = sp)
mutate(census, new_sp = recode(sp, lookup(look$old, look$new)))

# Overwrite
mutate(census, sp = recode(sp, lookup(look$old, look$new)))
}
\seealso{
\code{dplyr::recode()}

Other general functions to edit data in place: \code{\link{fill_na}},
  \code{\link{suffix_match}}, \code{\link{to_tidy_names}}
}
\concept{general functions to edit data in place}
